C51 COMPILER V9.57.0.0   MAIN                                                              08/03/2020 14:38:49 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN d:\My\keilmake\C51\Other\Time\out\Keil_C51\main.o
COMPILER INVOKED BY: D:\Maker\keil\C51\BIN\C51.exe D:\MY\KEILMAKE\C51\OTHER\TIME\SRC\MAIN.C PRINT(d:\My\keilmake\C51\Oth
                    -er\Time\out\Keil_C51\main.lst) OMF2 TABS(2) OPTIMIZE(8,SPEED) SMALL ROM(LARGE) INCDIR(d:\My\keilmake\C51\Other\Time\depe
                    -ndence;d:\My\keilmake\C51\Other\Time\src;d:\My\keilmake\C51\Other\Time\dependence\build-in\toolchain) DEFINE(__UVISION_V
                    -ERSION) OBJECT(d:\My\keilmake\C51\Other\Time\out\Keil_C51\main.o)

line level    source

*** WARNING C500 IN LINE 1 OF D:\MY\KEILMAKE\C51\OTHER\TIME\SRC\MAIN.C: LICENSE ERROR (R207(3): REGISTRY READ ERROR)

   1          #include "REG51.H"
   2          #define uint unsigned int
   3          #define uchar unsigned char
   4          
   5          sbit smg1 = P2^2;
   6          sbit smg2 = P2^3;
   7          sbit smg3 = P2^4;//数码管IO
   8          
   9          sbit kA = P3^1;
  10          sbit kB = P3^2;
  11          sbit kC = P3^3;
  12          
  13          uint m_sec = 0;//1ms
  14          uchar time[] = {0 , 0 , 12};
  15          
  16          uchar code smgz[]=// 显示0~9,H的值
  17          {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x40};
  18          
  19          void delay(uint s)
  20          {
  21   1          while(s--);
  22   1      }
  23          void Time0_Init()
  24          {
  25   1          TMOD|=0x01;
  26   1          TH0 = (65536 - 1000) >> 8;
  27   1          TL0 = (char)(65536 - 1000);//1ms
  28   1          ET0=1;
  29   1          TR0=1;
  30   1          EA=1;
  31   1      }
  32          void display(bit a, bit b, bit c){
  33   1          uchar i;
  34   1          char smg[8]={-1,-1,-1,-1,-1,-1,-1,-1,};
  35   1          if(a) {
  36   2              smg[0] = smgz[(time[0])%10];
  37   2              smg[1] = smgz[(time[0])/10];
  38   2          }
  39   1          if(b){
  40   2              smg[3] = smgz[(time[1])%10];
  41   2              smg[4] = smgz[(time[1])/10];
  42   2          }
  43   1          if(c){
  44   2              smg[6] = smgz[(time[2])%10];
  45   2              smg[7] = smgz[(time[2])/10];
  46   2          }
  47   1          if(a&&b&&c){
  48   2              smg[2] = smgz[10];
  49   2              smg[5] = smgz[10];
  50   2          }
  51   1          for (i = 0; i < 8; i++){
C51 COMPILER V9.57.0.0   MAIN                                                              08/03/2020 14:38:49 PAGE 2   

  52   2              smg1=((i)&0x01);
  53   2              smg2=((i>>1)&0x01);
  54   2              smg3=((i>>2)&0x01);
  55   2              if (smg[i]==-1)
  56   2                  P0 = 0x00;
  57   2              else
  58   2                  P0 = smg[i];
  59   2              delay(100);
  60   2              P0 = 0x00;
  61   2          }
  62   1      }
  63          uchar key_A(){
  64   1          if (kA == 0)
  65   1          {
  66   2              TR0 = 0;
  67   2              delay(100);
  68   2              if (kA == 0){
  69   3                  while (!kA);
  70   3                  return 1;
  71   3              }
  72   2          }
  73   1          return 0;
  74   1      }
  75          uchar key_Change(){
  76   1          if (kB == 0)//+
  77   1          {
  78   2              delay(100);
  79   2              if (kB == 0){
  80   3                  while (!kB);
  81   3                  return 2;
  82   3              }
  83   2          }
  84   1          if (kC == 0)//-
  85   1          {
  86   2              delay(100);
  87   2              if (kC == 0){
  88   3                  while (!kC);
  89   3                  return 0;
  90   3              }
  91   2          }
  92   1          return 1;
  93   1      }
  94          void time_Change(uchar log,uchar change,uchar max){
  95   1          if(time[3-log] == 0&&change == 0)
  96   1              time[3-log] = max;//下界
  97   1          else if(time[3-log] == max&&change == 2){
  98   2              time[3-log] = 0;//上界
  99   2          }else{
 100   2              time[3-log] += -1 + change;
 101   2          }
 102   1      }
 103          void main(){
 104   1          uchar log;
 105   1          Time0_Init();
 106   1          while (1)
 107   1          {
 108   2          log += key_A();// 改写模式标志位
 109   2          if(!log){
 110   3              display(1, 1, 1);
 111   3          }else{
 112   3              switch (log) {
 113   4                  case 1 :
C51 COMPILER V9.57.0.0   MAIN                                                              08/03/2020 14:38:49 PAGE 3   

 114   4                      time_Change(log, key_Change(), 23);
 115   4                      display(0, 0, 1);
 116   4                      break;
 117   4                  case 2 :
 118   4                      time_Change(log, key_Change(), 59);
 119   4                      display(0, 1, 0);
 120   4                      break;
 121   4                  case 3 :
 122   4                      time_Change(log, key_Change(), 59);
 123   4                      display(1, 0, 0);
 124   4                      break;
 125   4                  default:
 126   4                      log =0;
 127   4                      Time0_Init();
 128   4                      display(1, 1, 1);
 129   4                      break;
 130   4              }
 131   3          }
 132   2          }
 133   1      }
 134          void Time0 () interrupt 1
 135          {
 136   1          m_sec++;
 137   1          TH0 = (65536 - 1000) >> 8;
 138   1          TL0 = (char)(65536 - 1000);//1ms
 139   1          if (m_sec == 200)//200ms到一秒
 140   1          {
 141   2              m_sec = 0;
 142   2              time[0]++;
 143   2          }
 144   1          if (time[0] == 60)
 145   1          {
 146   2              time[1]++;
 147   2              time[0] = 0;
 148   2          }
 149   1          if (time[1] == 60)
 150   1          {
 151   2              time[2]++;
 152   2              time[1] = 0;
 153   2          }
 154   1          if (time[2] == 24)//24小时制
 155   1          {
 156   2              time[2] = 0;
 157   2          }
 158   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    445    ----
   CONSTANT SIZE    =     19    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
