#include <reg51.h>

#define uint unsigned int        //之后使用uint定义整形
#define uchar unsigned char        //之后使用uchar定义字符型

sbit SRCLK=P3^6;//一位数据锁存（上升沿信号）
sbit RCLK=P3^5;    //8位推出数据（并行输出）
sbit SER=P3^4;    //串行输入（记录8位数据） //点阵IO

uchar code led_c[17][8]={//列
{0x00,0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,},//0
{0x00,0x00,0x00,0x44,0x7E,0x40,0x00,0x00,},//1
{0x00,0x00,0x64,0x52,0x52,0x4C,0x00,0x00,},//2
{0x00,0x00,0x44,0x92,0x92,0x6C,0x00,0x00,},//3
{0x00,0x18,0x14,0x12,0x7F,0x10,0x00,0x00,},//4
{0x00,0x00,0x2E,0x4A,0x4A,0x32,0x00,0x00,},//5
{0x00,0x00,0x3C,0x4A,0x4A,0x30,0x00,0x00,},//6
{0x00,0x02,0x02,0x7A,0x06,0x02,0x00,0x00,},//7
{0x00,0x00,0x6C,0x92,0x92,0x92,0x6C,0x00,},//8
{0x00,0x00,0x4C,0x92,0x92,0x92,0x7C,0x00,},//9
{0x00,0x00,0xFC,0x12,0x12,0x12,0xFC,0x00,},//A
{0x00,0x00,0xFE,0x92,0x92,0x92,0x6C,0x00,},//B
{0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x00,},//C
{0x00,0x00,0x7E,0x42,0x42,0x42,0x3C,0x00,},//D
{0x00,0x00,0x7E,0x4A,0x4A,0x4A,0x00,0x00,},//E
{0x00,0x00,0x7E,0x0A,0x0A,0x0A,0x00,0x00,},//F
};

uchar code led_r[]={//行
0x7f,0xbf,0xdf,0xef,
0xf7,0xfb,0xfd,0xfe,
};

void delay(uint i)
{
    while(i--);
}

void LED_Byte(uchar dat){    //一位一位发送（一个一个灯点亮）（74HC595）
    uchar a;
    SRCLK = 1;
    RCLK = 1;
    for(a=0;a<8;a++){        //发送8位数据
        SER = dat << 7;        //从最高位开始发送
        dat >>= 1;
        SRCLK = 0;            //上升沿发送到锁存
        SRCLK = 1;
    }
    RCLK = 0;                //上升沿发送8位数据（并行输出）
    RCLK = 1;
}
void LED_LIGHT(uchar num){                //显示
    uchar i;
    for(i=0;i<8;i++) {
        P0=led_r[i];
        LED_Byte(led_c[num][i]);
        delay(100);
        LED_Byte(0x00);        //消隐
    }
}

uchar KEY_ALL(){                //按键处理函数
    uchar key,a;
    P1=0x0f;
    if(P1!=0x0f){                //读取按键是否按下
        delay(1000);
        if(P1!=0x0f){            //再次检测键盘是否按下
            P1=0X0f;            //测试列
            switch(P1){
                case(0X07):    key=0;break;
                case(0X0b):    key=1;break;
                case(0X0d): key=2;break;
                case(0X0e):    key=3;break;
            }
            P1=0Xf0;            //测试行
            switch(P1){
                case(0X70):    key=key;break;
                case(0Xb0):    key=key+4;break;
                case(0Xd0): key=key+8;break;
                case(0Xe0):    key=key+12;break;
            }
        }
    }                            //测试独立按键
    while (a<50&&P1!=0xf0){
        delay(1000);
        a++;
    }
    return key;
}

void main(){
    while (1)
    {
        LED_LIGHT(KEY_ALL());
    }
}